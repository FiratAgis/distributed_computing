.. include:: substitutions.rst

Introduction
============

In a regular system with multiple processes or disturbed systems with many members (which we will also call processes for simplicity), while working on the same data, it is common for many processes to want to access or modify the same piece of data. However, changing the data while the other is reading might create unwanted effects. We call these race conditions, where two or more processes race to work on the same piece of memory. We call the regions of code that access or modify the same shared memory a critical section. Mutual exclusion in shared memory is a common way of handling these race conditions by forcing processes to enter critical sections in a mutually exclusive fashion. This enables multiple processes to work on the same piece of data, which enables us to run algorithms that process a piece of data in a concurrent way.

The problem of mutual exclusion is a difficult one, as it requires working with multiple processes at the same time, by definition. It also requires mutual exclusion, to be precise, meaning the guarantee for the elimination of race conditions. This eliminates any best-effort approaches from consideration. In addition to these, synchronization is also necessary in the sense that there should be no confusion about which process is allowed to enter the critical section within the system.

While the above conditions are requirements, there are also many considerations for properties of the algorithm that are used for mutual exclusion that would be preferred. First of all, it should solve the problem of mutual exclusion with as few messages as possible. Flooding the network with messages might eliminate the existence of race conditions, as no process is able to access the critical section, which is an unoptimal solution to our problem, as we prefer work to be done within the system. Secondly, it should not hinder the performance of processes. This means minimizing overhead, computations, and stalling should be minimized, while preserving the guarantee of no race conditions. Lastly, the algorithm's space usage should be minimized, as wasteful space usage is unwanted in most cases.

Optimizing all of the preferred criteria at the same time, even with the absence of any of the necessary constraints, is impossible in most cases. When this is combined with harsh requirements, one true solution to our problem becomes impossible. Due to this, many different algorithms are being implemented to tackle this problem, each optimized in different ways. We will implement two of the oldest solutions to this problem, Peterson's :ref:`Algorithm <PetersonsAlgorithm>` [Peterson1981]_ and Bakery :ref:`Algorithm <BakeryAlgorithm>` [Lamport1974]_. These algorithms are well-tested and proven ones, which require minimal overhead and communication, with the downside of not containing ways to account for handling processes that do not exit the critical section and having a great amount of stalling while a process waits for permission to be let into the critical section.

Our primary contributions consist of the following:
    
    - Implementation of both the Peterson's Algorithm and Bakery Algorithm on the AHCv2 platform. The implementation specifics are detailed in Section XX.
    - Examination of the performance of these algorithms across diverse topologies and usage scenarios. Results from these investigations are outlined in Section XXX.